# Defining a Kuberentes Deployment

Now Vault has been configured you need to create a Kubernetes deployment that
will run your application.

The first step is to create a service account for the application.  This service
account will be used to authenticate to Vault.

Add the following to the file `./k8s/app.yaml':

```yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: payments
automountServiceAccountToken: false
```

## Defining a service

Next you need to define a service that will be used to access the application.

Add the following to the file `./k8s/app.yaml':

```yaml
---
apiVersion: v1
kind: Service
metadata:
  name: payments
spec:
  selector:
    app: payments
  ports:
    - protocol: TCP
      port: 8080
      targetPort: 8080
```

## Creating the application config

The application configuration that you have been using when running in development
mode was using the following configuration to authenticate with Vault using a
token:

```yaml
spring.cloud.vault:
  host: localhost
  scheme: http
  port: 8200
  fail-fast: true
  authentication: TOKEN
  token: ${VAULT_TOKEN}
```

When running the application in Kubernetes you will use the Kubernetes 
service acccount token. To make this configuration change you need to change
the authentication config from `TOKEN` to `KUBERNETES` and add the `role` that
you created earlier.

```yaml
authentication: KUBERNETES
kubernetes:
  role: payments
```

Add the following to the file `./k8s/app.yaml':

```yaml
---
apiVersion: v1
data:
  application.yml: |
    spring:
      jpa:
        show_sql: true
        hibernate:
          ddl-auto: none
        properties:
          hibernate:
            dialect: org.hibernate.dialect.PostgreSQLDialect
      datasource:
        driverClassName: org.postgresql.Driver
        url: jdbc:postgresql://10.6.0.180:5432/payments
    spring.cloud.vault:
      host: vault.default.svc.cluster.local
      scheme: http
      port: 8200
      fail-fast: true
      authentication: KUBERNETES
      kubernetes:
        role: payments
      kv:
        enabled: false
      database:
        enabled: true
        role: writer
        backend: database
        username-property: spring.datasource.username
        password-property: spring.datasource.password
    spring.config.import: vault://
kind: ConfigMap
metadata:
  creationTimestamp: "2020-09-10T21:09:34Z"
  name: payments-config
  namespace: default
```

## Adding the deployment

Finally you need to add the deployment that will run the application.
This deployment is pretty standard. It adds the service account that you
created earlier and mounts the application configuration as a volume.

When the application starts it will read the configuration from the
`application.yml` file that is mounted as a volume.  Spring will then attempt
to load the service account token that it expects to be mounted at 
`/var/run/secrets/kubernetes.io/serviceaccount/token`.  It uses this token
along with the role to authenticate with Vault and return a token that can
be used to access the secrets.

Add the following to the file `./k8s/app.yaml':

```yaml
---
apiVersion: apps/v1
kind: Deployment
metadata:
  creationTimestamp: null
  labels:
    app: payments
  name: payments 
spec:
  replicas: 1
  selector:
    matchLabels:
      app: payments
  template:
    metadata:
      labels:
        app: payments
    spec:
      serviceAccountName: payments 
      automountServiceAccountToken: true
      containers:
        - image: nicholasjackson/spring-vault-example:v0.0.3
          name: payments
          volumeMounts:
            - name: config-volume
              mountPath: /config
      volumes:
        - name: config-volume
          configMap:
            name: payments-config
```

With everything in place you can now deploy the application to Kubernetes.