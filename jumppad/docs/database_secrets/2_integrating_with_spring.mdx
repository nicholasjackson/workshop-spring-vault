# Configuring Spring Boot

Before we can use the dynamic credentials generated by Vault, we need to integrate Vault with our Spring Boot application. We will use the [Spring Cloud Vault](https://cloud.spring.io/spring-cloud-vault/reference/html/) library to integrate Vault with our Spring Boot application.

The first step is to configure the `application.yaml` file to connect to Vault. Add the following configuration to the `src/main/resources/application.yaml` file:

```yaml
spring.cloud.vault:
  vault:
    host: localhost
    scheme: http
    port: 8200
    fail-fast: true
    authentication: TOKEN
    token: ${VAULT_TOKEN}
```

This configuration is fine for development and does not have any authentication configured. We are going to pick up the 
Vault token that is configured in the environment variable `VAULT_TOKEN`.

## Username and password injection

While looking at the config you might have noticed that in the datasource configuration there was no username
and password configured. This is because we are going to use the dynamic credentials generated by Vault to connect 
to the database.

#### Existing configuration

```yaml
spring:
  jpa:
    show_sql: true
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  datasource:
    driverClassName: org.postgres.JDBC
    url: jdbc:postgresql://postgres.container.local.jmpd.in:5432/payments
```

Let's modify this configuration to use the dynamic credentials generated by Vault, to do this we need to add the following configuration to the `spring.cloud.vault` section `application.yaml` file. We are disabling the `kv` secrets or spring perform the default behaviour of attempting to read a secret from the kv store that has the same name of the application.

We are then cofiguring the `database` backend to be used as the source of the credentials. We are also specifying the role that we want to use to generate the credentials. The `username-property` and `password-property` are the properties that we are going to use to inject the username and password into the datasource configuration.

```yaml
  kv:
    enabled: false
  database:
    enabled: true
    role: writer
    backend: database
    username-property: spring.datasource.username
    password-property: spring.datasource.password
```

To enable the automatic credential injection we need to add one final section to the `application.yaml` file. This section tells Spring to import the configuration from Vault.

```yaml
spring.config.import: vault://
```

## Final application.yaml

Your final application.yaml file should look like this:

```yaml
logging:
  level:
    root: INFO
    org:
      springframework:
        vault:
          core:
            env: DEBUG
spring:
  jpa:
    show_sql: true
    hibernate:
      ddl-auto: none
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
  datasource:
    driverClassName: org.postgresql.Driver
    url: jdbc:postgresql://postgres.container.local.jmpd.in:5432/payments
spring.cloud.vault:
  host: localhost
  scheme: http
  port: 8200
  fail-fast: true
  authentication: TOKEN
  token: ${VAULT_TOKEN}
  kv:
    enabled: false
  database:
    enabled: true
    role: writer
    backend: database
    username-property: spring.datasource.username
    password-property: spring.datasource.password
spring.config.import: vault://
```

Next let's test the application